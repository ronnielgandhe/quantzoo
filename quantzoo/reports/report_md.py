"""Markdown report generation with plots."""

import json
from pathlib import Path
from typing import Dict, Any
from datetime import datetime

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import pandas as pd
import numpy as np


def generate_report(run_id: str, metrics: Dict[str, Any]) -> str:
    """
    Generate a comprehensive markdown report for a backtest run.
    
    Args:
        run_id: Unique identifier for the run
        metrics: Metrics dictionary containing all performance data
        
    Returns:
        Path to the generated report file
    """
    # Create reports directory if it doesn't exist
    reports_dir = Path("reports")
    reports_dir.mkdir(exist_ok=True)
    
    # Generate timestamp
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Create equity curve plot
    plot_path = None
    if "equity_curve" in metrics and metrics["equity_curve"]:
        plot_path = _create_equity_plot(run_id, metrics["equity_curve"])
    
    # Generate markdown content
    report_content = f"""# QuantZoo Backtest Report

**Run ID:** {run_id}  
**Generated:** {timestamp}  
**Strategy:** {metrics.get('strategy', 'Unknown')}  

## Configuration

- **Fees:** {metrics.get('fees_bps', 0):.1f} bps
- **Slippage:** {metrics.get('slippage_bps', 0):.1f} bps
- **Seed:** {metrics.get('seed', 42)}
- **Config Path:** {metrics.get('config_path', 'N/A')}

### Strategy Parameters

{_format_parameters(metrics.get('params', {}))}

## Performance Summary

| Metric | Value |
|--------|-------|
| Total Return | {metrics.get('total_return', 0):.2%} |
| Sharpe Ratio | {metrics.get('sharpe_ratio', 0):.3f} |
| Maximum Drawdown | {metrics.get('max_drawdown', 0):.2%} |
| Win Rate | {metrics.get('win_rate', 0):.2%} |
| Profit Factor | {metrics.get('profit_factor', 0):.2f} |
| Total Trades | {metrics.get('total_trades', 0)} |
| Winning Trades | {metrics.get('winning_trades', 0)} |
| Losing Trades | {metrics.get('losing_trades', 0)} |
| Average Trade | ${metrics.get('avg_trade', 0):.2f} |
| Average Win | ${metrics.get('avg_win', 0):.2f} |
| Average Loss | ${metrics.get('avg_loss', 0):.2f} |
| Largest Win | ${metrics.get('largest_win', 0):.2f} |
| Largest Loss | ${metrics.get('largest_loss', 0):.2f} |
| Gross Profit | ${metrics.get('gross_profit', 0):.2f} |
| Gross Loss | ${metrics.get('gross_loss', 0):.2f} |
| Exposure | {metrics.get('exposure', 0):.2%} |

## Risk Metrics

| Metric | Value | Description |
|--------|-------|-------------|
| VaR (95%) | {metrics.get('var_95', 'NA')} | Value-at-Risk at 95% confidence level |
| Expected Shortfall (95%) | {metrics.get('es_95', 'NA')} | Expected loss beyond VaR threshold |
| Sharpe Ratio | {metrics.get('sharpe_ratio', 0):.3f} | Risk-adjusted return measure |
| Maximum Drawdown | {metrics.get('max_drawdown', 0):.2%} | Peak-to-trough decline |
| Profit Factor | {metrics.get('profit_factor', 0):.2f} | Gross profit / Gross loss |
| Win Rate | {metrics.get('win_rate', 0):.2%} | Percentage of winning trades |

{_format_latency_metrics(metrics)}

{_format_storage_info(run_id, metrics)}

## Trade Analysis

{_format_trade_analysis(metrics)}

## Notes

This report was generated by QuantZoo's backtesting framework. All metrics are calculated on a mark-to-market basis with realistic fees and slippage applied.

**Disclaimer:** Past performance is not indicative of future results. This analysis is for educational and research purposes only.

---
*Generated by QuantZoo v0.1.0*
"""
    
    # Write report to file
    report_filename = f"backtest_report_{run_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
    report_path = reports_dir / report_filename
    
    with open(report_path, "w") as f:
        f.write(report_content)
    
    return str(report_path)


def _format_storage_info(run_id: str, metrics: Dict[str, Any]) -> str:
    """Format storage and persistence information."""
    content = ["## Data Storage", ""]
    content.append("| Storage Type | Location |")
    content.append("|--------------|----------|")
    content.append(f"| Trades Data | `artifacts/trades_{run_id}.parquet` |")
    content.append(f"| Equity Data | `artifacts/equity_{run_id}.parquet` |")
    content.append(f"| Metadata | `artifacts/quantzoo.duckdb` |")
    content.append("")
    
    # Add DuckDB query examples
    content.append("### Query Examples")
    content.append("")
    content.append("```sql")
    content.append(f"-- Query trades for this run")
    content.append(f"SELECT * FROM trades WHERE run_id = '{run_id}';")
    content.append("")
    content.append(f"-- Query equity curve for this run")
    content.append(f"SELECT * FROM equity WHERE run_id = '{run_id}';")
    content.append("")
    content.append("-- Get all run metadata")
    content.append("SELECT * FROM run_metadata ORDER BY timestamp DESC;")
    content.append("```")
    content.append("")
    
    return "\n".join(content)


def _format_latency_metrics(metrics: Dict[str, Any]) -> str:
    """Format latency metrics as markdown section."""
    latency_keys = [k for k in metrics.keys() if k.startswith('latency_')]
    
    if not latency_keys:
        return ""
    
    content = ["## Performance Metrics", ""]
    content.append("| Metric | Value |")
    content.append("|--------|-------|")
    
    if 'latency_ms_mean' in metrics:
        content.append(f"| Average Latency | {metrics['latency_ms_mean']:.2f} ms |")
    if 'latency_ms_p95' in metrics:
        content.append(f"| 95th Percentile Latency | {metrics['latency_ms_p95']:.2f} ms |")
    if 'latency_ms_max' in metrics:
        content.append(f"| Maximum Latency | {metrics['latency_ms_max']:.2f} ms |")
    
    content.append("")
    return "\n".join(content)


def _format_parameters(params: Dict[str, Any]) -> str:
    """Format strategy parameters as markdown table."""
    if not params:
        return "*No parameters available*"
    
    rows = []
    for key, value in params.items():
        if isinstance(value, bool):
            value_str = "Yes" if value else "No"
        elif isinstance(value, float):
            value_str = f"{value:.3f}"
        else:
            value_str = str(value)
        
        rows.append(f"| {key.replace('_', ' ').title()} | {value_str} |")
    
    if not rows:
        return "*No parameters available*"
    
    header = "| Parameter | Value |\n|-----------|-------|"
    return header + "\n" + "\n".join(rows)


def _format_walkforward_results(metrics: Dict[str, Any]) -> str:
    """Format walk-forward analysis results."""
    wf_keys = [
        "windows_total", "windows_profitable", "avg_window_return",
        "std_window_return", "worst_window_return", "best_window_return"
    ]
    
    if not any(key in metrics for key in wf_keys):
        return "*Walk-forward analysis data not available*"
    
    total_windows = metrics.get("windows_total", 0)
    profitable_windows = metrics.get("windows_profitable", 0)
    win_rate = (profitable_windows / total_windows * 100) if total_windows > 0 else 0
    
    return f"""| Metric | Value |
|--------|-------|
| Total Windows | {total_windows} |
| Profitable Windows | {profitable_windows} |
| Window Win Rate | {win_rate:.1f}% |
| Avg Window Return | {metrics.get('avg_window_return', 0):.2%} |
| Window Return Std | {metrics.get('std_window_return', 0):.2%} |
| Best Window | {metrics.get('best_window_return', 0):.2%} |
| Worst Window | {metrics.get('worst_window_return', 0):.2%} |"""


def _format_trade_analysis(metrics: Dict[str, Any]) -> str:
    """Format detailed trade analysis."""
    total_trades = metrics.get("total_trades", 0)
    if total_trades == 0:
        return "*No trades executed*"
    
    winning_trades = metrics.get("winning_trades", 0)
    losing_trades = metrics.get("losing_trades", 0)
    
    return f"""### Trade Distribution

- **Total Trades:** {total_trades}
- **Winning Trades:** {winning_trades} ({winning_trades/total_trades*100:.1f}%)
- **Losing Trades:** {losing_trades} ({losing_trades/total_trades*100:.1f}%)

### Trade Performance

- **Average Trade:** ${metrics.get('avg_trade', 0):.2f}
- **Average Winner:** ${metrics.get('avg_win', 0):.2f}
- **Average Loser:** ${metrics.get('avg_loss', 0):.2f}
- **Win/Loss Ratio:** {abs(metrics.get('avg_win', 0) / metrics.get('avg_loss', 1)) if metrics.get('avg_loss', 0) != 0 else 'N/A':.2f}

### Extremes

- **Largest Winner:** ${metrics.get('largest_win', 0):.2f}
- **Largest Loser:** ${metrics.get('largest_loss', 0):.2f}
"""


def _create_equity_plot(run_id: str, equity_curve: list) -> str:
    """
    Create and save equity curve plot.
    
    Args:
        run_id: Run identifier
        equity_curve: List of equity values
        
    Returns:
        Filename of saved plot
    """
    if not equity_curve:
        return None
    
    # Create figure
    plt.figure(figsize=(12, 6))
    
    # Plot equity curve
    x = range(len(equity_curve))
    plt.plot(x, equity_curve, linewidth=2, color='#2E86AB', label='Equity')
    
    # Calculate and plot drawdown
    peak = equity_curve[0]
    drawdown = []
    for equity in equity_curve:
        if equity > peak:
            peak = equity
        dd = (peak - equity) / peak * 100 if peak > 0 else 0
        drawdown.append(-dd)  # Negative for plotting below zero
    
    # Create secondary y-axis for drawdown
    ax1 = plt.gca()
    ax2 = ax1.twinx()
    
    ax2.fill_between(x, drawdown, 0, alpha=0.3, color='red', label='Drawdown %')
    ax2.set_ylabel('Drawdown (%)', color='red')
    ax2.tick_params(axis='y', labelcolor='red')
    
    # Format primary axis
    ax1.set_xlabel('Bars')
    ax1.set_ylabel('Equity ($)', color='#2E86AB')
    ax1.tick_params(axis='y', labelcolor='#2E86AB')
    ax1.grid(True, alpha=0.3)
    
    # Add title and formatting
    initial_equity = equity_curve[0]
    final_equity = equity_curve[-1]
    total_return = (final_equity - initial_equity) / initial_equity * 100
    
    plt.title(f'Equity Curve - Run {run_id}\n'
              f'Total Return: {total_return:.2f}% | '
              f'Final Equity: ${final_equity:,.0f}', 
              fontsize=14, pad=20)
    
    # Add legends
    ax1.legend(loc='upper left')
    ax2.legend(loc='upper right')
    
    # Tight layout
    plt.tight_layout()
    
    # Save plot
    plot_filename = f"equity_curve_{run_id}.png"
    plot_path = Path("reports") / plot_filename
    plt.savefig(plot_path, dpi=300, bbox_inches='tight')
    plt.close()
    
    return plot_filename


def generate_summary_table(metrics_file: str = "artifacts/metrics.json") -> str:
    """
    Generate a summary table of all runs from metrics file.
    
    Args:
        metrics_file: Path to metrics JSON file
        
    Returns:
        Markdown table string
    """
    try:
        with open(metrics_file, "r") as f:
            all_metrics = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return "*No metrics data available*"
    
    if not all_metrics:
        return "*No runs found*"
    
    # Create table header
    table = """| Run ID | Strategy | Return | Sharpe | Max DD | Trades | Win Rate |
|--------|----------|--------|--------|--------|--------|----------|
"""
    
    # Add rows for each run
    for run_id, metrics in all_metrics.items():
        table += f"| {run_id[:8]} | {metrics.get('strategy', 'N/A')} | "
        table += f"{metrics.get('total_return', 0):.2%} | "
        table += f"{metrics.get('sharpe_ratio', 0):.2f} | "
        table += f"{metrics.get('max_drawdown', 0):.2%} | "
        table += f"{metrics.get('total_trades', 0)} | "
        table += f"{metrics.get('win_rate', 0):.2%} |\n"
    
    return table